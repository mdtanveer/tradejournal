{% extends "layout.html" %}

{% block content %}
    <div class="container">
        <link rel="stylesheet" type="text/css" href="/static/content/chart.css">
        <div class="btn-toolbar mb-3" role="toolbar" aria-label="Toolbar with button groups">
            <div class="btn-group mr-2" role="group" aria-label="First group">
                <button type="button" class="btn btn-secondary btn-success" onclick="RenderPreviousChart();">
                    <span class="glyphicon glyphicon-chevron-left"></span>
                </button>
                <button type="button" class="btn btn-secondary btn-success" onclick="RenderNextChart();">
                    <span class="glyphicon glyphicon-chevron-right"></span>
                </button>
            </div>
            <div>
                <center>
                    <h5 id="title"></h5>
                </center>
            </div>
        </div>
        <div id="main">
            <div id="chart"></div>
        </div>
        {%if journalentry%}
        <form class="input-group" method="post" role="form">
            <input type="text" class="form-control" id="title" name="title">
            <div class="input-group-btn">
                <button type="submit" class="btn btn-success">
                    &zwnj;<span class="glyphicon glyphicon-camera"></span>
                </button>
                <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    &zwnj;<span class="caret"></span>
                    <span class="sr-only">Toggle Dropdown</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right">
                    <li>
                        <a href="javascript:DeleteCurrentChart();">
                            Delete
                        </a>
                    </li>
                </ul>
            </div>
        </form>
        {%else%}
        <div class="btn-toolbar mb-3" role="toolbar" aria-label="Toolbar with button groups">
            <div class="btn-group mr-2" role="group" aria-label="First group">
                <button type="button" class="btn btn-secondary btn-success" onclick="RenderCurrentChart('2h');">I</button>
                <button type="button" class="btn btn-secondary btn-success" onclick="RenderCurrentChart('1d');">D</button>
                <button type="button" class="btn btn-secondary btn-success" onclick="RenderCurrentChart('1wk');">W</button>
            </div>
        </div>
        {%endif%}
    </div>
        <script type="text/javascript" src="/static/scripts/d3.v4.min.js"></script>
        <script type="text/javascript" src="/static/scripts/techan.min.js"></script>
        <script>
    var dataWindowSize = 250;
    var windowW = Math.round(window.innerWidth*0.81);
    var windowH = Math.round(window.innerHeight*0.70);
    var currentScrip = "";

    var dim = {
        width: windowW, height: windowH,
        margin: { top: 10, right: 0, bottom: 50, left: 0 },
        ohlc: { height: 305 },
        indicator: { height: 65, padding: 5 }
    };


    dim.plot = {
        width: dim.width - dim.margin.left - dim.margin.right,
        height: dim.height - dim.margin.top - dim.margin.bottom
    };
    dim.ohlc.height = Math.floor(dim.plot.height*0.80)
    dim.indicator.height = Math.floor(dim.plot.height*0.20)

    dim.indicator.top = dim.ohlc.height+dim.indicator.padding;
    dim.indicator.bottom = dim.indicator.top+dim.indicator.height+dim.indicator.padding;

    var indicatorTop = d3.scaleLinear()
            .range([dim.indicator.top, dim.indicator.bottom]);

    var parseDate = d3.timeParse("%Y-%m-%d %H:%M:%S");

    var x = techan.scale.financetime()
            .range([0, dim.plot.width]);

    var y = d3.scaleLinear()
            .range([dim.ohlc.height, 0]);

    var yVolume = d3.scaleLinear()
            .range([y(0), y(0.2)]);

    var plotHeikenAshi = false;

    if (!plotHeikenAshi)
    {
        var candlestick = techan.plot.candlestick()
                .xScale(x)
                .yScale(y);
    }
    else
    {
        var candlestick = techan.plot.heikinashi()
                .xScale(x)
                .yScale(y);

        var heikinashiIndicator = techan.indicator.heikinashi();
    }


    var ichimoku = techan.plot.ichimoku()
            .xScale(x)
            .yScale(y);

    var xAxis = d3.axisBottom(x);

    var yAxis = d3.axisLeft(y)
            .tickFormat(d3.format(",.3s"));

    var volumeAxis = d3.axisRight(yVolume)
            .ticks(3)
            .tickFormat(d3.format(",.3s"));

    var svg = d3.select("#chart").append("svg")
            .attr("width", windowW)
            .attr("height", windowH)
        .append("g")
            .attr("transform", "translate(" + dim.margin.left + "," + dim.margin.top + ")");

    var defs = svg.append("defs");

    defs.append("clipPath")
            .attr("id", "ohlcClip")
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", dim.plot.width)
            .attr("height", dim.ohlc.height);

    defs.selectAll("indicatorClip").data([0])
        .enter()
            .append("clipPath")
            .attr("id", function(d, i) { return "indicatorClip-" + i; })
        .append("rect")
            .attr("x", 0)
            .attr("y", function(d, i) { return indicatorTop(i); })
            .attr("width", dim.plot.width)
            .attr("height", dim.indicator.height);


    var stochasticScale = d3.scaleLinear()
            .range([indicatorTop(0)+dim.indicator.height, indicatorTop(0)]);

    var stochastic = techan.plot.stochastic()
            .xScale(x)
            .yScale(stochasticScale);

    var stochasticIndicator = techan.indicator.stochastic()

    var stochasticAxisLeft = d3.axisLeft(stochasticScale)
            .ticks(3);

    var stochasticAnnotationLeft = techan.plot.axisannotation()
            .axis(stochasticAxisLeft)
            .orient("left")
            .format(d3.format(',.2f'));

    var indicatorSelection = svg.selectAll("svg > g.indicator").data(["stochastic"]).enter()
             .append("g")
                .attr("class", function(d) { return d + " indicator"; });

    indicatorSelection.append("g")
            .attr("class", "axis right")
            .attr("transform", "translate(" + x(1) + ",0)");

    indicatorSelection.append("g")
            .attr("class", "axis left")
            .attr("transform", "translate(" + x(0) + ",0)");

    indicatorSelection.append("g")
            .attr("class", "indicator-plot")
            .attr("clip-path", function(d, i) { return "url(#indicatorClip-" + i + ")"; });

    var ichimokuIndicator = techan.indicator.ichimoku();
    // Don't show where indicators don't have data
    var indicatorPreRoll = ichimokuIndicator.kijunSen()+ichimokuIndicator.senkouSpanB();
    var volume = techan.plot.volume()
            .accessor(candlestick.accessor())   // Set the accessor to a ohlc accessor so we get highlighted bars
            .xScale(x)
            .yScale(yVolume);

    var tradearrow = techan.plot.tradearrow()
        .xScale(x)
        .yScale(y)
        .orient(function(d) { return d.type.startsWith("buy") ? "up" : "down"; })

    svg.append("g")
            .attr("class", "ichimoku")
            .attr("clip-path", "url(#ohlcClip)");

    svg.append("g")
            .attr("class", "candlestick")
            .attr("clip-path", "url(#ohlcClip)");

    svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + dim.indicator.bottom + ")");

    svg.append("g")
            .attr("class", "y axis")
        .append("text")
            .attr('id', 'charttitle')
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", ".71em")
                .style("text-anchor", "end")
            {%if journalentry %}
        .text("{{journalentry.symbol}}");
            {%endif%}
    svg.append("g")
            .attr("class", "volume")
            .attr("clip-path", "url(#ohlcClip)");

    svg.append("g")
              .attr("class", "tradearrow")
                .attr("clip-path", "url(#ohlcClip)");
    {%if journalentry %}
    const tradearrowoffsetperc = 0.01;
    const tradearrowoffsetentry = 1 + {{ -1 if journalentry.direction == 'LONG' else 1}}* tradearrowoffsetperc;
    const tradearrowoffsetexit = 1 + {{ 1 if journalentry.direction == 'LONG' else -1}}* tradearrowoffsetperc;

    const trades = [
                {
                    date: parseDate("{{ journalentry.entry_time|formatdatetimed3 }}"),
                    type: "{{ 'buy' if journalentry.direction == 'LONG' else 'sell'}}",
                    price: {{ journalentry.entry_price }}* tradearrowoffsetentry,
                    quantity: {{ journalentry.quantity }} 
            }
            {% if not journalentry.is_open() %}
            , {
                date: parseDate("{{ journalentry.exit_time|formatdatetimed3 }}"),
                    type: "{{ 'sell' if journalentry.direction == 'LONG' else 'buy'}}",
                    price: {{ journalentry.exit_price }}* tradearrowoffsetexit,
                quantity: {{ journalentry.quantity }}
            }
            {%endif%}
        ];
            {%else%}
            const trades = [];
            {%endif%}

    function draw(data) {
        if (plotHeikenAshi)
        {
            candlestickData = heikinashiIndicator(data);
        }
        else
        {
            candlestickData = data;
        }
        var ichimokuData = ichimokuIndicator(data);

        var stochasticData = stochasticIndicator(data);
        stochasticScale.domain(techan.scale.plot.stochastic(stochasticData).domain());

        x.domain(data.map(ichimokuIndicator.accessor().d));
        // Calculate the y domain for visible data points (ensure to include Kijun Sen additional data offset)
        var y_domain = techan.scale.plot.ichimoku(ichimokuData.slice(indicatorPreRoll - ichimokuIndicator.kijunSen())).domain();
        y_domain = [y_domain[0] * 0.95, y_domain[1] * 1.05];
        y.domain(y_domain);
        yVolume.domain(techan.scale.plot.volume(data.slice(indicatorPreRoll-ichimokuIndicator.kijunSen())).domain());

        // Logic to ensure that at least +KijunSen displacement is applied to display cloud plotted ahead of ohlc
        x.zoomable().clamp(false).domain([indicatorPreRoll, data.length+ichimokuIndicator.kijunSen()]);

        svg.selectAll("g.candlestick").datum(candlestickData).call(candlestick);
        svg.selectAll("g.ichimoku").datum(ichimokuData).call(ichimoku);
        svg.selectAll("g.x.axis").call(xAxis);
        svg.selectAll("g.y.axis").call(yAxis);
        svg.selectAll("g.volume").datum(data).call(volume);
        svg.selectAll("g.stochastic .indicator-plot").datum(stochasticData).call(stochastic);
        svg.selectAll("g.stochastic .axis.left").call(stochasticAxisLeft);
        if (trades.length == 2 && trades[1].date > data[data.length - 1].date) {
            chartTrades = [...trades].splice(0, 1);
        }
        else {
            chartTrades = trades;
        }
        svg.selectAll("g.tradearrow").selectAll("*").remove();
        svg.selectAll("g.tradearrow").datum(chartTrades).call(tradearrow);
    }

            var charts = JSON.parse('{{ charts | safe}}');
            var g_timeFrame = '{{ timeframe }}';

            function combine1hto2h(array, row1, row2) {
                if (row1['date'] != row2['date']) {
                    array = array.concat([row1]);
                    return [1, array];
                }
                else {
                    array = array.concat([{
                        'date': row1['date'],
                        'time': row1['time'],
                        'open': row1['open'],
                        'high': Math.max(parseFloat(row1['high']), parseFloat(row2['high'])),
                        'low': Math.min(parseFloat(row1['low']), parseFloat(row2['low'])),
                        'close': row2['close'],
                        'volume': parseFloat(row1['volume']) + parseFloat(row2['volume'])
                    }]);
                    return [2, array];
                }
            }

            function To2HChart(data) {
                var newData = new Array();
                var i = 0;
                for (i = 0; i < data.length - 1;) {
                    res = combine1hto2h(newData, data[i], data[i + 1]);
                    i += res[0];
                    newData = res[1];
                }
                if (i < data.length - 1) {
                    i = data.length - 1;
                    newData = newData.concat(data[i]);
                }
                return newData;
            }

        function RenderChart(i, timeFrame) {
            if (i >= charts.length) 
            {
                    return;
            }

            document.getElementById('title').innerText = charts[i].title + " (" + (i+1) + " of " + charts.length + ")";
            {%if not journalentry%}
            document.getElementById('charttitle').innerHTML = charts[currentChartIndex].data + ' (' + timeFrame[1].toUpperCase() + ')';
            {%endif%}
            document.getElementById('main').hidden = false;
            function D3_DataCallback(error, data) {
                charts[i].raw_data = data;
                if (timeFrame == '2h' || timeFrame == '1h') {
                    data = To2HChart(data);
                }
                data = data.map(function (d) {
                    // Open, high, low, close generally not required, is being used here to demonstrate colored volume
                    // bars
                    return {
                        date: parseDate(d.date + ' ' + d.time),
                        volume: +d.volume,
                        open: +d.open,
                        high: +d.high,
                        low: +d.low,
                        close: +d.close
                    };
                })
                if (dataWindowSize < data.length) {
                    data = data.slice(data.length - dataWindowSize, data.length)
                }
                draw(data);
            }
            if (charts[i].raw_data == null) {
                var temp = charts[i].relativeUrl.split('?');
                params = new URLSearchParams(temp[1]);
                params.set('tf', timeFrame);
                relativeUrl = temp[0] + '?' + params;
                d3.csv(relativeUrl, D3_DataCallback)
            } else {
                D3_DataCallback(null, charts[i].raw_data);
            }
        }

        var currentChartIndex = 0;
        if (charts.length > 0) {
                currentChartIndex = charts.length - 1;
            RenderChart(currentChartIndex, g_timeFrame);
        }
        else {
            document.getElementById('title').innerText = "No charts available";
            document.getElementById('main').hidden = true;
            }

        function RenderCurrentChart(timeFrame) {
            charts[currentChartIndex].raw_data = null;
            RenderChart(currentChartIndex, timeFrame);
        }

        function RenderNextChart() {
            currentChartIndex++;
            if (currentChartIndex >= charts.length)
                currentChartIndex = 0;
            if (charts.length > 0)
                RenderChart(currentChartIndex, g_timeFrame);
        }

        function RenderPreviousChart() {
            currentChartIndex--;
            if (currentChartIndex < 0)
                currentChartIndex = charts.length-1;
            if (charts.length > 0)
                RenderChart(currentChartIndex, g_timeFrame);
            }
        {%if journalentry%}
            function DeleteCurrentChart() {
                $.ajax({
                    url: 'charts/' + charts[currentChartIndex].key + '/delete',
                    type: 'DELETE',
                    success: function(result) {
                        window.location.reload();
                    }
                });
            }
        {%endif%}
        </script>
{% endblock %}
